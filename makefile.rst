========
Makefile
========

.. highlight:: makefile

書き方
======

簡単な例
--------

とてもシンプルな例::

	.PHONY: all clean

	TARG=8.out

	CFILES=\
		a.c\
		b.c\

	OFILES=$(CFILES:%.c=%.8)

	all: $(TARG)

	$(TARG): $(OFILES)
		8l -o $@ $^

	%.8: %.c
		8c -o $@ $<

	clean:
		rm -f $(OFILES) $(TARG)

ターゲット関連の変数
--------------------

`トリビアなmakefile入門 <http://www.jsk.t.u-tokyo.ac.jp/~k-okada/makefile/>`_
によると、以下の自動変数が存在する。

====== ==========================================================
変数名 説明
====== ==========================================================
``$@`` ターゲットファイル名
``$%`` ターゲットがアーカイブメンバだったときのターゲットメンバ名
``$<`` 最初の依存するファイルの名前
``$?`` ターゲットより新しいすべての依存するファイル名
``$^`` すべての依存するファイルの名前
``$+`` Makefileと同じ順番の依存するファイルの名前
``$*`` サフィックスを除いたターゲットの名前
====== =========================================================

静的パターンルール
------------------

特定のターゲットに対してのみルールを適用する::

	targets: %.8: %.c

``targets`` は複数書くことができ、ワイルドカードも使える。

通常のルールとの違いは、例えば通常は *\*.c* ファイルは自分で書くけれど、
別のデータからコードを自動生成する場合などに、このルールが使える。

ワイルドカードを含む例::

	%_autogen.c: %.c: %.csv

* `makefileを作る <http://te2u.hatenablog.jp/entry/2013/11/09/132529>`_

困った事例
==========

拡張子を除いたファイル名だけ欲しい
----------------------------------

``basename`` と ``notdir`` を使う::

	VAR=a/b.c

	all:
		echo $(basename $(notdir $(VAR)))

ファイル名の一部が欲しい
------------------------

ワイルドカード(``%``)は1箇所しか使えないしそれほど柔軟ではない。
ファイル名の特定部分が必要な場合、``word`` と ``subst`` を使う方法が簡単。

以下はパッケージファイルからバージョンを取り出す例::

	RPM=app-2.4.0-1.el7.x86_64.rpm

	all:
		echo $(word 2,$(subst -, ,$(RPM)))
